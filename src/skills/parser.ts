/**
 * SKILL.md 文件解析器
 * 解析 YAML frontmatter 和 markdown 内容
 */

import { readFile } from 'fs/promises';
import { basename, dirname } from 'path';
import type { SkillEntry, SkillFrontmatter, SkillSource } from './types.js';

/**
 * 解析 YAML frontmatter
 * 简化实现，不依赖外部 YAML 解析库
 */
function parseYamlFrontmatter(yaml: string): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  const lines = yaml.split('\n');
  let currentKey: string | null = null;
  let currentArray: string[] | null = null;
  let currentIndent = 0;

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;

    // 检测数组项
    if (trimmed.startsWith('- ')) {
      if (currentKey && currentArray) {
        currentArray.push(trimmed.slice(2).trim());
      }
      continue;
    }

    // 检测键值对
    const colonIndex = trimmed.indexOf(':');
    if (colonIndex > 0) {
      // 保存之前的数组
      if (currentKey && currentArray) {
        result[currentKey] = currentArray;
        currentArray = null;
      }

      const key = trimmed.slice(0, colonIndex).trim();
      const value = trimmed.slice(colonIndex + 1).trim();

      if (value === '') {
        // 可能是数组或嵌套对象的开始
        currentKey = key;
        currentArray = [];
        currentIndent = line.search(/\S/);
      } else {
        // 简单的键值对
        result[key] = parseYamlValue(value);
        currentKey = null;
        currentArray = null;
      }
    }
  }

  // 保存最后一个数组
  if (currentKey && currentArray && currentArray.length > 0) {
    result[currentKey] = currentArray;
  }

  return result;
}

/**
 * 解析 YAML 值
 */
function parseYamlValue(value: string): unknown {
  // 去除引号
  if ((value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))) {
    return value.slice(1, -1);
  }

  // 布尔值
  if (value === 'true') return true;
  if (value === 'false') return false;

  // 数字
  const num = Number(value);
  if (!isNaN(num)) return num;

  // 字符串
  return value;
}

/**
 * 解析 SKILL.md 文件内容
 */
export function parseSkillContent(
  content: string,
  filePath: string,
  source: SkillSource
): SkillEntry | null {
  const trimmedContent = content.trim();

  // 检查是否有 frontmatter
  if (!trimmedContent.startsWith('---')) {
    // 没有 frontmatter，使用文件名作为 skill 名称
    const name = basename(dirname(filePath));
    return {
      frontmatter: { name },
      content: trimmedContent,
      filePath,
      source,
    };
  }

  // 查找 frontmatter 结束位置
  const endIndex = trimmedContent.indexOf('---', 3);
  if (endIndex === -1) {
    // frontmatter 格式错误
    console.warn(`Invalid frontmatter in ${filePath}`);
    return null;
  }

  // 解析 frontmatter
  const yamlContent = trimmedContent.slice(3, endIndex).trim();
  const parsed = parseYamlFrontmatter(yamlContent);

  // 构建 frontmatter 对象
  const frontmatter: SkillFrontmatter = {
    name: (parsed.name as string) || basename(dirname(filePath)),
    title: parsed.title as string | undefined,
    description: parsed.description as string | undefined,
    version: parsed.version as string | undefined,
    author: parsed.author as string | undefined,
    enabled: parsed.enabled !== false, // 默认启用
    tags: parsed.tags as string[] | undefined,
    priority: parsed.priority as number | undefined,
  };

  // 解析 eligibility
  if (parsed.eligibility && typeof parsed.eligibility === 'object') {
    frontmatter.eligibility = parsed.eligibility as SkillFrontmatter['eligibility'];
  } else {
    // 尝试解析顶级 eligibility 字段
    if (parsed.os || parsed.binaries || parsed.envVars) {
      frontmatter.eligibility = {
        os: parsed.os as string[] | undefined,
        binaries: parsed.binaries as string[] | undefined,
        envVars: parsed.envVars as string[] | undefined,
      };
    }
  }

  // 提取 markdown 内容
  const markdownContent = trimmedContent.slice(endIndex + 3).trim();

  return {
    frontmatter,
    content: markdownContent,
    filePath,
    source,
  };
}

/**
 * 从文件路径解析 Skill
 */
export async function parseSkillFile(
  filePath: string,
  source: SkillSource
): Promise<SkillEntry | null> {
  try {
    const content = await readFile(filePath, 'utf-8');
    return parseSkillContent(content, filePath, source);
  } catch (error) {
    console.error(`Failed to parse skill file ${filePath}:`, error);
    return null;
  }
}
